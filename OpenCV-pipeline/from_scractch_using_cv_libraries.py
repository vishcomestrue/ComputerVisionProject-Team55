# -*- coding: utf-8 -*-
"""from_scractch_using_cv_libraries.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wUyt5xrnwoiFlgu51q5rFqae2hvA_i42
"""

# Importing necessary libraries
import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files


# Function to crop black borders from a stitched panorama using contours
def crop_black_borders(image):
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    _, thresh = cv2.threshold(gray, 1, 255, cv2.THRESH_BINARY)
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    if not contours:
        return image

    cnt = max(contours, key=cv2.contourArea)
    x, y, w, h = cv2.boundingRect(cnt)
    return image[y:y+h, x:x+w]

# Function to apply feather blending on the overlapping area of stitched images
def feather_blend(base, warped, mask_warped):
    base_float = base.astype(np.float32)
    warped_float = warped.astype(np.float32)
    mask_base = (base > 0).astype(np.float32)
    mask_warped = mask_warped.astype(np.float32)

    blend_mask = mask_base + mask_warped
    blend_mask[blend_mask == 0] = 1.0

    result = (base_float * mask_base + warped_float * mask_warped) / blend_mask
    result = np.clip(result, 0, 255).astype(np.uint8)
    return result

# Function to stitch 2 images
def stitch_pair_sift_with_blending(base_img, new_img):
    gray1 = cv2.cvtColor(base_img, cv2.COLOR_BGR2GRAY)
    gray2 = cv2.cvtColor(new_img, cv2.COLOR_BGR2GRAY)

    sift = cv2.SIFT_create()
    kp1, des1 = sift.detectAndCompute(gray1, None)
    kp2, des2 = sift.detectAndCompute(gray2, None)

    if des1 is None or des2 is None:
        return None

    bf = cv2.BFMatcher()
    matches = bf.knnMatch(des1, des2, k=2)
    good = [m for m, n in matches if m.distance < 0.75 * n.distance]

    if len(good) < 10:
        print("Not enough good matches.")
        return None

    src_pts = np.float32([kp1[m.queryIdx].pt for m in good]).reshape(-1, 1, 2)
    dst_pts = np.float32([kp2[m.trainIdx].pt for m in good]).reshape(-1, 1, 2)
    H, _ = cv2.findHomography(dst_pts, src_pts, cv2.RANSAC, 5.0)

    h1, w1 = base_img.shape[:2]
    h2, w2 = new_img.shape[:2]

    corners_new = np.float32([[0, 0], [0, h2], [w2, h2], [w2, 0]]).reshape(-1, 1, 2)
    warped_corners = cv2.perspectiveTransform(corners_new, H)
    corners_base = np.float32([[0, 0], [0, h1], [w1, h1], [w1, 0]]).reshape(-1, 1, 2)

    all_corners = np.concatenate((warped_corners, corners_base), axis=0)
    [xmin, ymin] = np.int32(all_corners.min(axis=0).ravel() - 0.5)
    [xmax, ymax] = np.int32(all_corners.max(axis=0).ravel() + 0.5)
    trans = np.array([[1, 0, -xmin],
                      [0, 1, -ymin],
                      [0, 0, 1]])

    warped = cv2.warpPerspective(new_img, trans @ H, (xmax - xmin, ymax - ymin))
    mask_warped = cv2.warpPerspective(np.ones_like(new_img, dtype=np.uint8) * 255, trans @ H, (xmax - xmin, ymax - ymin))
    translated_base = np.zeros_like(warped)
    translated_base[-ymin:h1 - ymin, -xmin:w1 - xmin] = base_img

    blended = feather_blend(translated_base, warped, mask_warped)
    return blended


# Function to find sequence of images in which to be stitched
def stitch_images_sequence(images):
    base = images[0]
    for i in range(1, len(images)):
        print(f"Stitching image {i}...")
        stitched = stitch_pair_sift_with_blending(base, images[i])
        if stitched is None:
            print(f"Skipping image {i}.")
        else:
            base = stitched
    return crop_black_borders(base)

def test_with_your_images():
    print("ðŸ“· Upload 2 or more overlapping images (in any order).")
    uploaded = files.upload()
    if len(uploaded) < 2:
        print("Please upload at least two images.")
        return

    os.makedirs('user_uploads', exist_ok=True)
    images = []

    for i, (name, data) in enumerate(uploaded.items()):
        path = f"user_uploads/img_{i}_{name}"
        with open(path, 'wb') as f:
            f.write(data)
        img = cv2.imread(path)
        if img is not None:
            images.append(img)

    if len(images) < 2:
        print("At least 2 valid images required.")
        return

    print("Stitching and blending images...")
    result = stitch_images_sequence(images)

    if result is None:
        print("Final stitching failed.")
        return

    result_path = "user_uploads/stitched_result_cleaned.jpg"
    cv2.imwrite(result_path, result)

    plt.figure(figsize=(20, 10))
    for i, img in enumerate(images):
        plt.subplot(1, len(images) + 1, i + 1)
        plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
        plt.title(f"Image {i}")
        plt.axis('off')

    plt.subplot(1, len(images) + 1, len(images) + 1)
    plt.imshow(cv2.cvtColor(result, cv2.COLOR_BGR2RGB))
    plt.title("Stitched Image")
    plt.axis('off')
    plt.tight_layout()
    plt.show()

    print("Panorama saved to:", result_path)
    print("Download it with:")
    print(f"files.download('{result_path}')")
    return result_path
test_with_your_images()